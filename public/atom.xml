<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title></title>
    <link rel="self" type="application/atom+xml" href="https://blog.dziban.net/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://blog.dziban.net"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2024-04-03T00:00:00+00:00</updated>
    <id>https://blog.dziban.net/atom.xml</id>
    <entry xml:lang="en">
        <title>Eval using the lexical environment in LispWorks</title>
        <published>2024-04-03T00:00:00+00:00</published>
        <updated>2024-04-03T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.dziban.net/posts/lispworks-eval-in-lexenv/"/>
        <id>https://blog.dziban.net/posts/lispworks-eval-in-lexenv/</id>
        
        <content type="html" xml:base="https://blog.dziban.net/posts/lispworks-eval-in-lexenv/">&lt;p&gt;One of the things that surprised me when I learned Common Lisp was
that &lt;code&gt;eval&lt;&#x2F;code&gt; happens in the &lt;code&gt;nil&lt;&#x2F;code&gt; lexical environment&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;. This means
that none of the lexical variables, functions or macros surrounding
the eval are available within the evaluated form.&lt;&#x2F;p&gt;
&lt;p&gt;Take this example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;((x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;eval&lt;&#x2F;span&gt;&lt;span&gt; &amp;#39;(+ x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)))
&lt;&#x2F;span&gt;&lt;span&gt;  
&lt;&#x2F;span&gt;&lt;span&gt;Error: The variable X is unbound.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The reason why that surprised me is that one of the first things that
I tried when I learned about lisp symbolic capabilities was to build a
symbolic
&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Derivative&quot;&gt;differentiator&lt;&#x2F;a&gt;. You&#x27;d give
it a function, it would symbolically compute the derivative using
the chain rule and then evaluate it. I built a very basic one with
only a couple of rules to test the idea and it seemed to work, the
problem was when I wanted to evaluate the resulting form.&lt;&#x2F;p&gt;
&lt;p&gt;What I attempted was something like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;defun &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;dx &lt;&#x2F;span&gt;&lt;span&gt;(func x)
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;((derivative (differentiate func :over &amp;#39;x)))
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;eval&lt;&#x2F;span&gt;&lt;span&gt; derivative)))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you try this of course you&#x27;ll face the same issue we found above.
&lt;code&gt;Error: The variable X is unbound&lt;&#x2F;code&gt;. I was confused, I thought symbolic
computation WAS the point of Lisp. At that point I learned about the
dynamic vs lexical environment and I started making sense of what I
was seeing, but I was frustrated and it seemed that what I wanted to
do was impossible.&lt;&#x2F;p&gt;
&lt;p&gt;Indeed, you could do it with a macro, but then you cannot pass it
arbitrary functions at runtime, everything has to be predefined.&lt;&#x2F;p&gt;
&lt;p&gt;Another option was available which was to declare &lt;code&gt;x&lt;&#x2F;code&gt; as special&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;,
but then you needed to define some special variables, and the
expressions could only use those. It would work but it was not ideal.&lt;&#x2F;p&gt;
&lt;p&gt;At that point I stopped, frustrated, and learned other parts of the
language. Recently I had a need for something similar again and so I
set to find a solution now that I had some more Common Lisp experience
under my belt.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;progv&quot;&gt;&lt;code&gt;PROGV&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;http:&#x2F;&#x2F;clhs.lisp.se&#x2F;Body&#x2F;s_progv.htm&quot;&gt;&lt;code&gt;PROGV&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; is a Common Lisp
special form that takes three or more arguments, a list of dynamic
bindings to create, a list of values to set the bindings to and any
number of forms. The forms are evaluated in order with the given 
dynamic bindings set.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;defun &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;test-fun &lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;  (+ *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;x&lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(progv &amp;#39;(*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;x&lt;&#x2F;span&gt;&lt;span&gt;*) &amp;#39;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;  (test-fun))
&lt;&#x2F;span&gt;&lt;span&gt;  
&lt;&#x2F;span&gt;&lt;span&gt;=&amp;gt; 5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With this we can emulate a en eval in a lexical env by setting
everything we have in the lexical environment as a dynamic variable
inside a &lt;code&gt;PROGV&lt;&#x2F;code&gt; and then executing the eval. It will behave as if
it was running on the lexenv.&lt;&#x2F;p&gt;
&lt;p&gt;This would be a good moment to see where we are going:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;((x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;eval&lt;&#x2F;span&gt;&lt;span&gt;-in-lexenv (+ x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)))
&lt;&#x2F;span&gt;&lt;span&gt;  
&lt;&#x2F;span&gt;&lt;span&gt;=&amp;gt; 6
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which behind the scenes would be transformed into a &lt;code&gt;PROGV&lt;&#x2F;code&gt; form:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span&gt;(progv &amp;#39;(x) &amp;#39;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;eval&lt;&#x2F;span&gt;&lt;span&gt; &amp;#39;(+ x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now the problem is, &lt;code&gt;eval-in-lexenv&lt;&#x2F;code&gt; cannot modify its surroundings,
macros are powerful but not &lt;em&gt;THAT&lt;&#x2F;em&gt; powerful&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;. We could ask the
users to do something like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;eval&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;with&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;((x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;)) (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;eval&lt;&#x2F;span&gt;&lt;span&gt; &amp;#39;(+ x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;))))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And then build a code walker, check bindings inside, capture some
bindings from outside, etc. But that is very complicated and there are
probably plenty of edge cases and problems, it&#x27;s far too complicated
and too alien for the user to be worth it in this case.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;introspecting-the-lexical-environment&quot;&gt;Introspecting the lexical environment&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;DEFMACRO&lt;&#x2F;code&gt;&#x27;s arglist has a hidden gem that I overlooked the first time
I checked the documentation. With &lt;code&gt;&amp;amp;environment&lt;&#x2F;code&gt; we can ask the lisp
compiler to give us the lexical environment&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#4&quot;&gt;4&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; at the macro call site.&lt;&#x2F;p&gt;
&lt;p&gt;For example&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;defmacro &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;capture-env &lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;environment env)
&lt;&#x2F;span&gt;&lt;span&gt;  env)
&lt;&#x2F;span&gt;&lt;span&gt;  
&lt;&#x2F;span&gt;&lt;span&gt;(flet ((plus (a b) (+ a b)))
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;((x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    (capture-env)))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;=&amp;gt; #&amp;lt;Environment 
&lt;&#x2F;span&gt;&lt;span&gt;       venv (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;#&amp;lt;Venv 275146972128&lt;&#x2F;span&gt;&lt;span&gt;  X&amp;gt;)  
&lt;&#x2F;span&gt;&lt;span&gt;	   fenv ((PLUS . &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;#&amp;lt;COMPILER::FLET-INFO #&amp;lt;interpreted&lt;&#x2F;span&gt;&lt;span&gt; function (SUBFUNCTION (FLET PLUS) :UNKNOWN) 40200038FC&amp;gt;&amp;gt;)) 
&lt;&#x2F;span&gt;&lt;span&gt;	   benv NIL 
&lt;&#x2F;span&gt;&lt;span&gt;	   tenv NIL&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It contains variables, functions, blocks and tags in the lexical
environment. But, I&#x27;m pretty sure this struct is internal and the
intrface may not be stable. Re-reading the LispWorks documentation
today I found this function:
&lt;a href=&quot;https:&#x2F;&#x2F;www.lispworks.com&#x2F;documentation&#x2F;lw80&#x2F;lw&#x2F;lw-sys-93.htm&quot;&gt;&lt;code&gt;SYSTEM:MAP-ENVIRONMENT&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.
With this function you can introspect everything in the lexical
environment you pass as an argument. Let&#x27;s write a function to get all
variable names in the lexical environment for example.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;defun &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;lexical-vars &lt;&#x2F;span&gt;&lt;span&gt;(env)
&lt;&#x2F;span&gt;&lt;span&gt;  &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;Given an environment object, return all lexical vars&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;((vars &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;nil&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    (system:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;-environment env
&lt;&#x2F;span&gt;&lt;span&gt;     :variable
&lt;&#x2F;span&gt;&lt;span&gt;     (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(name kind info)
&lt;&#x2F;span&gt;&lt;span&gt;       (declare (ignore info))
&lt;&#x2F;span&gt;&lt;span&gt;       (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;when &lt;&#x2F;span&gt;&lt;span&gt;(eq kind :lexical)
&lt;&#x2F;span&gt;&lt;span&gt;         (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;pushnew&lt;&#x2F;span&gt;&lt;span&gt; name vars))))
&lt;&#x2F;span&gt;&lt;span&gt;    vars))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Pretty self-explanatory, ask lispworks to map over all the variables,
and then we push them into a list. We filter them by &lt;code&gt;:LEXICAL&lt;&#x2F;code&gt; type
because we are also given dynamic variables that have been overwritten
in the current lexical scope, but we don&#x27;t need to use those since
they are already in the dynamic scope.&lt;&#x2F;p&gt;
&lt;p&gt;Now let&#x27;s create the &lt;em&gt;pièce de résistance&lt;&#x2F;em&gt;, the &lt;code&gt;eval-in-lexenv&lt;&#x2F;code&gt;
macro:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;defmacro &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;eval-in-lexenv &lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;body body &amp;amp;environment env)
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;((lenv-vars (lexical-vars env)))
&lt;&#x2F;span&gt;&lt;span&gt;     `(progv &amp;#39;,lenv-vars (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;list&lt;&#x2F;span&gt;&lt;span&gt; ,@lenv-vars)
&lt;&#x2F;span&gt;&lt;span&gt;	    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;eval&lt;&#x2F;span&gt;&lt;span&gt; &amp;#39;,(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;car&lt;&#x2F;span&gt;&lt;span&gt; body)))))
&lt;&#x2F;span&gt;&lt;span&gt;		
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;((x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;eval&lt;&#x2F;span&gt;&lt;span&gt;-in-lexenv (+ x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)))
&lt;&#x2F;span&gt;&lt;span&gt;  
&lt;&#x2F;span&gt;&lt;span&gt;=&amp;gt; 4
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Short and sweet, we get all the lexical variables, then we pass them
both as names and values to &lt;code&gt;PROGV&lt;&#x2F;code&gt;. As names we pass them quoted, so
we get bind the same symbols we have of lexical vars as dynamic
variables, for values we pass them unquoted inside of a &lt;code&gt;(LIST ...)&lt;&#x2F;code&gt;
so they get evaluated and capture the values from the surrounding
lexical env, thus setting the dynamic variables to the same values.&lt;&#x2F;p&gt;
&lt;p&gt;There you go, a way to eval in the lexical environment in about 14
lines of easy to understand common lisp code. This code is LispWorks
exclusive tho, but I&#x27;m sure there are ways to do it in SBCL, since
&lt;code&gt;&amp;amp;environment&lt;&#x2F;code&gt; works there as well. I may add it in the future if
someone sends me a solution that works in SBCL.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;limitations&quot;&gt;Limitations&lt;&#x2F;h2&gt;
&lt;p&gt;This implementation doesn&#x27;t allow using functions and macros from the
lexical env (as defined by &lt;code&gt;MACROLET&lt;&#x2F;code&gt; or &lt;code&gt;FLET&lt;&#x2F;code&gt;) although there are
ways around it, like binding the function to a variable and using
&lt;code&gt;FUNCALL&lt;&#x2F;code&gt; or &lt;code&gt;APPLY&lt;&#x2F;code&gt; inside the eval.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;((fn (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;lambda &lt;&#x2F;span&gt;&lt;span&gt;(a b) (+ a b))))
&lt;&#x2F;span&gt;&lt;span&gt;   (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;eval&lt;&#x2F;span&gt;&lt;span&gt;-in-lexenv (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;funcall&lt;&#x2F;span&gt;&lt;span&gt; fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;3 4&lt;&#x2F;span&gt;&lt;span&gt;)))
&lt;&#x2F;span&gt;&lt;span&gt;   
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;; =&amp;gt; 7
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Another thing is that this macro depends on being called at the
lexical environment you want to evaluate it.&lt;&#x2F;p&gt;
&lt;p&gt;If you try to call this macro from within the body of a macro function
you&#x27;ll be capturing the call environment inside the macro. Of course
if you use it as part of the unevaluated returned form of the macro
everything will work as expected, since that will be evaluated in the
correct lexical environment.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;The End&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;The nil lexical environment, as the name says has no bindings at all&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;Special and dynamic variables are the same thing, special variables are variables bound in the dynamic environment&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;Recently I learned about a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;abuseofnotation&#x2F;termlisp&quot;&gt;term rewriting lisp&lt;&#x2F;a&gt;, which could actually do things like this potentially. I think that particular version is not quite powerful enough for this, but there is no reason it couldn&#x27;t I think.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;4&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;4&lt;&#x2F;sup&gt;
&lt;p&gt;I think it&#x27;s not only the lexical environment, but the general environment that overlays the dynamic environment, it also contains special variables overriden in the current lexical environment for example.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Delivering a LispWorks application</title>
        <published>2024-04-02T00:00:00+00:00</published>
        <updated>2024-04-02T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.dziban.net/posts/delivering-a-lispworks-application/"/>
        <id>https://blog.dziban.net/posts/delivering-a-lispworks-application/</id>
        
        <content type="html" xml:base="https://blog.dziban.net/posts/delivering-a-lispworks-application/">&lt;p&gt;WARNING: This is a living document. As I understand more of the
LispWorks delivery system i&#x27;ll add more.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;changelog&quot;&gt;Changelog&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;2024-04-02&lt;&#x2F;code&gt; - Added article&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lispworks&quot;&gt;LispWorks&lt;&#x2F;h2&gt;
&lt;p&gt;I recently got my &lt;a href=&quot;https:&#x2F;&#x2F;www.lispworks.com&#x2F;&quot;&gt;LispWorks&lt;&#x2F;a&gt; HobbyistDV
license in order to productionize a couple of my Common Lisp application
development. SBCL is amazing but as I am planning to develop a couple
of services that may potentially get into commercial territory I
wanted to get familiar with the commercial CL implementations in case
I need them. The IDE and CAPI are also amazing and I&#x27;ve already
developed a couple of personal GUIs to help me with some of my
workflows.&lt;&#x2F;p&gt;
&lt;p&gt;Yesterday I set out to deliver my first server application, let&#x27;s
build our understanding bit by bit.&lt;&#x2F;p&gt;
&lt;p&gt;LispWorks has &lt;a href=&quot;https:&#x2F;&#x2F;www.lispworks.com&#x2F;documentation&#x2F;lw80&#x2F;deliv&#x2F;deliv.htm&quot;&gt;extensive
documentation&lt;&#x2F;a&gt;
on the delivery system. You can check there for more details.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-delivery-system&quot;&gt;The Delivery System&lt;&#x2F;h2&gt;
&lt;p&gt;The LW delivery system allows you to take a common lisp application
and generate a self-contained binary with everything it needs to run.&lt;&#x2F;p&gt;
&lt;p&gt;The system basically takes an image (lisp program state in memory) and
turns it into an executable that contains the necessary LispWorks
runtime to run it. This already gives us a hint of what we will have
to do. We have to setup the image at build time.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-deliver-script&quot;&gt;The deliver script&lt;&#x2F;h2&gt;
&lt;p&gt;The deliver script is a lisp file that does just that, it sets up the
image as you need it for your final program. Here you load all your
code, all your dependencies, enable any features you need (we&#x27;ll get
to that later), and finally call the &lt;code&gt;deliver&lt;&#x2F;code&gt; function with some
parameters. You do mostly as you do when you start a lisp repl to work
on some project.&lt;&#x2F;p&gt;
&lt;p&gt;The simplest deliver script could be something like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;in-package&lt;&#x2F;span&gt;&lt;span&gt; :cl-user)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;defun &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;main &lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;format &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;t &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;LispWorks delivered application~%&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;))
&lt;&#x2F;span&gt;&lt;span&gt;  
&lt;&#x2F;span&gt;&lt;span&gt;(deliver &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;#&amp;#39;main &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;.&#x2F;app&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We define a main function to be our application code and call
&lt;code&gt;delivery&lt;&#x2F;code&gt; with some parameters we&#x27;ll explore later. In this case we
are not loading any external application code, just defining a
function.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can ask LW to build this and run the resulting binary&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; lispworks&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt; -build&lt;&#x2F;span&gt;&lt;span&gt; deliver.lisp
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;Shaking&lt;&#x2F;span&gt;&lt;span&gt; stage : Saving image
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;Build&lt;&#x2F;span&gt;&lt;span&gt; saving image: app
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;Build&lt;&#x2F;span&gt;&lt;span&gt; saved image: &#x2F;home&#x2F;marcecoll&#x2F;common-lisp&#x2F;test-deliver&#x2F;app
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;Delivery&lt;&#x2F;span&gt;&lt;span&gt; successful - app
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; .&#x2F;app
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;LispWorks&lt;&#x2F;span&gt;&lt;span&gt; delivered application
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is quite easy. Let&#x27;s check what those arguments to &lt;code&gt;deliver&lt;&#x2F;code&gt;
mean. The first argument, &lt;code&gt;#&#x27;main&lt;&#x2F;code&gt; in the above script, is the entry
point, the function that will be called when running the resulting
binary. The second one (&lt;code&gt;&amp;quot;.&#x2F;app&amp;quot;&lt;&#x2F;code&gt;) is the path for the binary that
will be generated. The third one (&lt;code&gt;0&lt;&#x2F;code&gt;) is how hard we want LispWorks
to try to make our image smaller and it&#x27;s called &lt;code&gt;level&lt;&#x2F;code&gt;
internally.. It is a number from 0 to 5, and the higher the level the
more runtime LispWorks removes. It also applies some optimizations
like converting methods into functions in some cases and stuff like
that. Cool!&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s check what was the size of the generated &lt;code&gt;app&lt;&#x2F;code&gt; binary.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; ls&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt; -lh &lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;grep&lt;&#x2F;span&gt;&lt;span&gt; app
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;-rwxr-xr-x&lt;&#x2F;span&gt;&lt;span&gt; 1 marcecoll users 47M abr  2 12:18 app
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;47MB is pretty big for a simple print, let&#x27;s ask LispWorks to reduce
it, let&#x27;s set the level to 5 and rebuild.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;Delivery&lt;&#x2F;span&gt;&lt;span&gt; successful - app
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; ls&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt; -lh &lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;grep&lt;&#x2F;span&gt;&lt;span&gt; app
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;-rwxr-xr-x&lt;&#x2F;span&gt;&lt;span&gt; 1 marcecoll users 7,9M abr  2 12:28 app
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; .&#x2F;app
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;Error:&lt;&#x2F;span&gt;&lt;span&gt; Attempt to invoke function *%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;APPLY&lt;&#x2F;span&gt;&lt;span&gt;-INTERPRETED-FUNCTION* on arguments (#&amp;lt;interpreted function &lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;#:NIL 412003FC4C&amp;gt; #:NIL).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;APPLY-INTERPRETED-FUNCTION*&lt;&#x2F;span&gt;&lt;span&gt; was removed by Delivery.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;Check&lt;&#x2F;span&gt;&lt;span&gt; that all functions are compiled before delivery if possible.  If you need to run non-compiled functions after delivery, pass :KEEP-EVAL T to DELIVER.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;404001F790 &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;???&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;Quitting
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Ruh. Roh. What&#x27;s going on here? By default LispWorks creates functions
as interpreted functions, when tree shaking the image LispWorks also
removed the ability to eval functions since it expects everything to
be compiled.&lt;&#x2F;p&gt;
&lt;p&gt;We can do two things here:&lt;&#x2F;p&gt;
&lt;p&gt;Either add the &lt;code&gt;:KEEP-EVAL T&lt;&#x2F;code&gt; to the &lt;code&gt;deliver&lt;&#x2F;code&gt; arguments, or add
&lt;code&gt;(compile &#x27;main)&lt;&#x2F;code&gt; before the call to &lt;code&gt;deliver&lt;&#x2F;code&gt;. In both cases the
image doesn&#x27;t increase in size too much. It stays in 7,9M, so it
doesn&#x27;t really matter. It also depends in what your application
uses. If you rely on runtime &lt;code&gt;eval&lt;&#x2F;code&gt; then you will want to &lt;code&gt;:KEEP-EVAL T&lt;&#x2F;code&gt; 
anyway. If you are loding your code with quicklisp this is usually
handled for you, since quicklisp uses &lt;code&gt;compile-file&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This exemplifies a bit more how the delivery system works. It
literally takes the image state as is and depending on the level it
removes as many features as possible to reduce the image size, this
may break some of your code that relies on features that have been
removed. There are very little build checks to make sure the
application will work after very aggressive tree shaking!&lt;&#x2F;p&gt;
&lt;p&gt;Unless you have a particular need to reduce the image further I
recommend starting with level 0 or 1 if that&#x27;s enough, since it&#x27;s less
likely some feature you depend on will be removed. If you do need a
higher level, &lt;code&gt;deliver&lt;&#x2F;code&gt; has a lot of flags to control what is and what
is not removed, make sure to check those out and test the resulting
binary extensively.&lt;&#x2F;p&gt;
&lt;p&gt;This is unlike any other system I&#x27;ve worked with and I think it&#x27;s
important to highlight it. Most systems build stage is about code
building and state is usually left for a separate step or at
initialization time. Of course there are ways to do it but they get
hairy quite fast. Because of how image-based builds work, you can
build state at this stage. Anything you do, variables you set, hash
tables you fill, trees you generate will get embedded in the resulting
image.&lt;&#x2F;p&gt;
&lt;p&gt;This means that precomputing something is not only feasible but easy
to do if needed. To me is a little bit analogous to functions vs
macros, where you can do computation at compile time instead of
runtime. I&#x27;ve done similar things with rust, but it always feels
non-native and hacky, I want to explore a little bit more what can be
done with this in the future.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-more-complex-example&quot;&gt;A more complex example&lt;&#x2F;h2&gt;
&lt;p&gt;This is the deliver script for an application I&#x27;m building:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;in-package&lt;&#x2F;span&gt;&lt;span&gt; :cl-user)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;require &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;remote-debugger-client&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;require &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;tty-inspect&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;load &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;~&#x2F;quicklisp&#x2F;setup.lisp&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;(ql:quickload :ami)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;;; Load the sites before delivering, since we won&amp;#39;t be able to
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;;; load them afterwards.
&lt;&#x2F;span&gt;&lt;span&gt;(ami.helpers:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;load&lt;&#x2F;span&gt;&lt;span&gt;-sites)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;multiple-value-bind &lt;&#x2F;span&gt;&lt;span&gt;(sec min hr day mon yr dow dst-p tz)
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;get-decoded-time&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;((commit (uiop:run-program &amp;#39;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;rev-parse&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;--short&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;HEAD&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;                                  :output &amp;#39;(:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt; :stripped &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;t&lt;&#x2F;span&gt;&lt;span&gt;))))
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;setf&lt;&#x2F;span&gt;&lt;span&gt; ami.config:*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;build&lt;&#x2F;span&gt;&lt;span&gt;* 
&lt;&#x2F;span&gt;&lt;span&gt;          (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;format &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;nil &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;~4,&amp;#39;0d-~2,&amp;#39;0d-~2,&amp;#39;0d (~a)&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; yr mon day commit))))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(lw:deliver &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;#&amp;#39;ami:start-ami &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;.&#x2F;ami&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;            :multiprocessing &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;t
&lt;&#x2F;span&gt;&lt;span&gt;            :startup-bitmap-file &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;nil
&lt;&#x2F;span&gt;&lt;span&gt;            :&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;delete&lt;&#x2F;span&gt;&lt;span&gt;-packages &amp;#39;(ql)
&lt;&#x2F;span&gt;&lt;span&gt;            :keep-pretty-printer &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;t&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This application is basically a web server that can contain multiple
sites. Let&#x27;s break it down&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;require &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;remote-debugger-client&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;require &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;tty-inspect&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This loads two features of LispWorks that we want for the final image,
the remote debugger (explained in the next section) and &lt;code&gt;tty-inspect&lt;&#x2F;code&gt;
to be able to run &lt;code&gt;(inspect *)&lt;&#x2F;code&gt; in the application. When run from a
normal listener, inspect automatically loads this feature when
executed. However we cannot do that in the resulting executable since
we will have removed it.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;load &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;~&#x2F;quicklisp&#x2F;setup.lisp&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;(ql:quickload :ami)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Fairly self-explanatory, I setup quicklisp and then use it to load my
system. This makes sure that both my code and all the dependencies
will be availabe in the resulting image.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span style=&quot;color:#999580;&quot;&gt;;; Load the sites before delivering, since we won&amp;#39;t be able to
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;;; load them afterwards.
&lt;&#x2F;span&gt;&lt;span&gt;(ami.helpers:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;load&lt;&#x2F;span&gt;&lt;span&gt;-sites)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is a helper function that goes over everything in the &lt;code&gt;sites&#x2F;&lt;&#x2F;code&gt;
folder and loads it using quicklisp. Making sure that the code for the
sites and all their dependencies are available in the image. This is
needed since &lt;code&gt;compile-file&lt;&#x2F;code&gt; is not available at runtime in the
delivered applications.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;multiple-value-bind &lt;&#x2F;span&gt;&lt;span&gt;(sec min hr day mon yr dow dst-p tz)
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;get-decoded-time&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;  (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;((commit 
&lt;&#x2F;span&gt;&lt;span&gt;          (uiop:run-program &amp;#39;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;git&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;rev-parse&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;--short&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;HEAD&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;                            :output &amp;#39;(:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt; :stripped &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;t&lt;&#x2F;span&gt;&lt;span&gt;))))
&lt;&#x2F;span&gt;&lt;span&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;setf&lt;&#x2F;span&gt;&lt;span&gt; ami.config:*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;build&lt;&#x2F;span&gt;&lt;span&gt;* 
&lt;&#x2F;span&gt;&lt;span&gt;          (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;format &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;nil 
&lt;&#x2F;span&gt;&lt;span&gt;		      &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;~4,&amp;#39;0d-~2,&amp;#39;0d-~2,&amp;#39;0d (~a)&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; 
&lt;&#x2F;span&gt;&lt;span&gt;			  yr mon day commit))))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Small code snippet that saves the date and the commit in the
&lt;code&gt;ami.config:*build*&lt;&#x2F;code&gt; variable. Here you can see an example of
state building in the image. A very simple one though.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span&gt;(lw:deliver &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;#&amp;#39;ami:start-ami &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#60ac39;&quot;&gt;.&#x2F;ami&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;            :multiprocessing &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;t
&lt;&#x2F;span&gt;&lt;span&gt;            :&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;delete&lt;&#x2F;span&gt;&lt;span&gt;-packages &amp;#39;(ql)
&lt;&#x2F;span&gt;&lt;span&gt;            :keep-pretty-printer &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;t&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Finally calling deliver, apart from the arguments we have already
looked at we&#x27;ve added some keyword arguments to control what is kept
and what isn&#x27;t.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;:multiprocessing&lt;&#x2F;code&gt; is off by default unless it&#x27;s a CAPI
application. As this application uses hunchentoot it needs
multiprocessing to run all the handler threads.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;:delete-packages &#x27;(ql)&lt;&#x2F;code&gt; removes quicklisp form the resulting image
since I don&#x27;t need runtime quicklisp support. Quicklisp is actually
quite useless at runtime in delivered applications since LispWorks
removes the &lt;code&gt;compile-file&lt;&#x2F;code&gt; function.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;:keep-pretty-printer t&lt;&#x2F;code&gt; is needed for &lt;code&gt;tty-inspect&lt;&#x2F;code&gt; to work, since it
needs to pretty print objects.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;remote-debugging-on-delivered-applications&quot;&gt;Remote Debugging on delivered applications&lt;&#x2F;h2&gt;
&lt;p&gt;There is one thing that is pretty bad of delivered applications, they
cannot run slynk&#x2F;swank servers. The server runs fine but they depend
on &lt;code&gt;compile-file&lt;&#x2F;code&gt; and that is unconditionally removed in all delivered
applications (I think it&#x27;s because they don&#x27;t want you creating a
competing product to LispWorks using their own tools). Sadly not even
the sly repl works.&lt;&#x2F;p&gt;
&lt;p&gt;Thankfully they do have a solution to at least part of what sly
offers.  You can not change code on the fly on a delivered image, but
you can at least open a listener and a debugger to a delivered
application.&lt;&#x2F;p&gt;
&lt;p&gt;You can setup either the IDE or the application to be the debugger
server, in my case I&#x27;ve setup the application to be the server since
it will be always running and I can connect from somewhere else with
my IDE. Let&#x27;s see how that works.&lt;&#x2F;p&gt;
&lt;p&gt;You have to first load the &lt;code&gt;remote-debugger-client&lt;&#x2F;code&gt; feature in the
deliver script. Then you need to startup the server somewhere in your
initialization tree:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fefbec;color:#6e6b5e;&quot;&gt;&lt;code&gt;&lt;span&gt;(dbg:start-client-remote-debugging-server :announce t)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This starts a tcp server at the default port (21102, you can change it
with the &lt;code&gt;:port&lt;&#x2F;code&gt; keyword arg).&lt;&#x2F;p&gt;
&lt;p&gt;Then from the IDE you need to &lt;code&gt;(require &amp;quot;remote-debugger-full&amp;quot;)&lt;&#x2F;code&gt; and
&lt;code&gt;(dbg:ide-connect-remote-debugging &amp;quot;host&amp;quot; :open-a-listener t)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This will connect at the default port on the given &lt;code&gt;host&lt;&#x2F;code&gt; and open a
listener window connected to that application.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;package-troubleshooting&quot;&gt;Package Troubleshooting&lt;&#x2F;h2&gt;
&lt;p&gt;As I find problems delivering some packages I&#x27;ll add them here as
reference.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;clack-lack&quot;&gt;Clack&#x2F;Lack&lt;&#x2F;h3&gt;
&lt;p&gt;Clack&#x2F;Lack loads middleware dynamically at runtime using quicklisp.
You need to explicitly add the middlewares as dependencies in the asdf
system so the are loaded with the main system. Or else you&#x27;ll get
quicklisp errors when running the application.&lt;&#x2F;p&gt;
&lt;p&gt;For example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span&gt;(asdf:defsystem ...
&lt;&#x2F;span&gt;&lt;span&gt;	:depends-on (:lack
&lt;&#x2F;span&gt;&lt;span&gt;	             :lack&#x2F;middleware&#x2F;session
&lt;&#x2F;span&gt;&lt;span&gt;	             :lack&#x2F;middleware&#x2F;static))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It also loads the backend server dynamically, so when you run it on
the repl it&#x27;s possible everything runs correctly since it will load
&lt;code&gt;hunchentoot&lt;&#x2F;code&gt; for you, but you need to depend on it explicitly for a
delivered application.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;The End&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Explorative Programming</title>
        <published>2024-03-26T00:00:00+00:00</published>
        <updated>2024-03-26T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.dziban.net/essays/explorative-programming/"/>
        <id>https://blog.dziban.net/essays/explorative-programming/</id>
        
        <content type="html" xml:base="https://blog.dziban.net/essays/explorative-programming/">&lt;p&gt;I am very bad at planning and visualizing what a program should look
before I start writing it. I&#x27;m sure a lot of other developers are in
that boat as well. I&#x27;d even venture to say that (almost?) all
developers have a hard time doing that even if they think they
understand the problem. Well, that&#x27;s probably actually the root of the
issue. Without writing or tackling them, it&#x27;s hard to understand
problems. You can only reach so far by thinking very hard in
isolation.&lt;&#x2F;p&gt;
&lt;p&gt;In my case the only real way I can tackle a problem is to start
writing code and playing with the problem and its data. I can talk
about how I approach the process at another time, but I need to explore
the problem space to find its limits, its edge cases, what areas are well
lit and which are in shadows. I cannot think of this in the abstract.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;I think I&#x27;m not alone in this. Hopefully?&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The problem is that most development environments are not designed to
help with the exploratory nature of this way of mapping a problem
space. They seem to be designed around what the end-program needs to
look like. Well-structured files in clean hierarchies and packaged
within cleanly delimited interfaces and modules. Who can write those
from the start? My guess is no-one.&lt;&#x2F;p&gt;
&lt;p&gt;There is a &lt;em&gt;rigidness&lt;&#x2F;em&gt; in our current development environments that
makes this important first step a lot harder than it should be. This
rigidness actively works against us, and prevents us from
understanding problems.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rigidness&quot;&gt;Rigidness&lt;&#x2F;h2&gt;
&lt;p&gt;What are the sources of this rigidness? I believe there are several and this
is not a exhaustive list, just the ones that I find most annoying and the ones
I&#x27;ve been looking for solutions for.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Long feedback cycles&lt;&#x2F;strong&gt;, caused mainly by two things:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Build steps&lt;&#x2F;strong&gt;, if you need to recompile or rebuild the system,
it incurs a cost everytime you try something new.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Loss of program state&lt;&#x2F;strong&gt;, even if your language doesn&#x27;t need a
build step, most languages are not designed to keep your program
state evolving as you evolve the code and their data structures.
This is a huge source of friction, and it&#x27;s a huge cost to pay
every time you wanna try something new.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;File based organization&lt;&#x2F;strong&gt;, right from the start you need to start
deciding what goes where. Of course I think most of us start with a
single file, full of random functions and tests. But at some point
this file becomes unbearable, impossible to find what you are
looking for. At that point you have to make decisions and start
splitting the file at logical points. Deal with what is private and
what is not. It may not seem like much, but it&#x27;s very annoying.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Bad system introspection&lt;&#x2F;strong&gt;, most languages require you to
implement text-based outputs for your internal data so you can
actually inspect what is going on.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Bad solutions for tree-based exploration&lt;&#x2F;strong&gt;, there are usually
several directions that look good when tackling a problem and once
you decide on one of them it&#x27;s very costly to try the rest. The
version control systems we have are not designed for this kind of
work, they require the user to create snapshots when the user
wants. If they have forgotten to do it at some point, that snapshot
is lost. And I can just speak for my experience here, but while I&#x27;m
doing this exploratory work I never know what I wanna save and what
not and what avenue will be worth exploring. I don&#x27;t wanna be
thinking about any of that either.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Bad Collaboration Story&lt;&#x2F;strong&gt;, the same systems I talk about in the
last point are also the way we do collaboration in software
development right now, tools like &lt;code&gt;git&lt;&#x2F;code&gt; or &lt;code&gt;mercurial&lt;&#x2F;code&gt;. If they are
a failure for tree-based exploration, then they cannot work to
collaborate on exploration. They are already lacking the needed
info for collaborating.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This rigidness is creatin so much friction when it comes to tackling
new and complex problems, both alone and in small teams. It requires
so much upfront investment that I think we are missing out on a lot of
new and interesting ideas because it&#x27;s costly to do so.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;If we had better exploratory programming tooling we could tackle
more complex problems with less people&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;There you go, that&#x27;s my thesis. We need to have better, interactive,
exploratory and &lt;em&gt;playful&lt;&#x2F;em&gt; development environments.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-step-in-this-direction&quot;&gt;A step in this direction&lt;&#x2F;h2&gt;
&lt;p&gt;Recently I&#x27;ve been spending more and more time writing Common Lisp
after years of writing Python, Rust, C and Javascript&#x2F;Typescript.  And
it&#x27;s not only because of things like macros and definitely not because
of the ecosystem. It&#x27;s because it&#x27;s the environment that more closely
matches my development process. The feedback cycle is immediate, it
allows very good introspection of every object in the system, and it
makes a lot of effort to keep your program state after changing
anything&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The amazing thing about Common Lisp as a development environment is
that it covers the whole range, from exploring to production. It
covers the high level, live reloading, macro writing, interactive side
and the performance-oriented, debugging, fast, robust side that you
want in order to deploy your systems.&lt;&#x2F;p&gt;
&lt;p&gt;It still requires you to use files, working in the REPL-only brings
its own set of problems. REPL and files are hard to keep in
sync. That&#x27;s another thing that what I&#x27;m development helps with, if
you remove the files, there&#x27;s nothing to keep in sync.&lt;&#x2F;p&gt;
&lt;p&gt;And it offers no help for the last two points&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; I made above.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;an-idea-for-what-comes-next&quot;&gt;An idea for what comes next&lt;&#x2F;h2&gt;
&lt;p&gt;I&#x27;ve started work on an alternative system. It&#x27;s not currently in a
usable state but it&#x27;s in a working state and I&#x27;m fairly close to
dogfooding it.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ve decided to use Common Lisp as a base language for this
development environment. I didn&#x27;t want to have to create a whole
language from scratch to test out these ideas, I tend to get into
useless rabbitholes that detract from what I&#x27;m trying to do, not this
time. Common Lisp as I said already has what I consider to be the
local maxima for my workflow and has the tools to extend the language
in the direction I want. It&#x27;s the perfect testing grounds.&lt;&#x2F;p&gt;
&lt;p&gt;There are two features I&#x27;m starting with in this system:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Non-linear editing of the source&lt;&#x2F;strong&gt; Getting away from file based
organization, you have a database of symbols and you can bring them
and hide them as you please. There is a concept of a workspace,
where you can see only the definitions for the symbols you need and
nothing else. These workspaces can be saved and restored. That way
you can have different &amp;quot;Notebooks&amp;quot;, depending on the problem you
are solving, with only the definitions you need at any given time.
This solves the code organization problem and reduces the friction
of starting something.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Per-symbol history&lt;&#x2F;strong&gt;, we keep the history of every single version
of functions, &lt;code&gt;defvar&lt;&#x2F;code&gt;, &lt;code&gt;defparameter&lt;&#x2F;code&gt;, &lt;code&gt;defclass&lt;&#x2F;code&gt;, &lt;code&gt;defmacro&lt;&#x2F;code&gt;, etc
you have created and sent to the REPL. You can navigate the tree,
inspect the history, go back in time. This tree is built
automatically as you re-define any symbol. You can diff between
different states and even merge versions. This works at per-symbol
granularity. This attempts to solve point number 4. You can recurse
into design sub-trees and go back in time without needing to manage
history manually.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Currently all of this is implemented by having all symbols in an
SQLite database and with a custom Emacs mode. You have a tree of
definitions and we have mappings of &lt;code&gt;(package, symbol) -&amp;gt; definition&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Common Lisp makes this extremely easy, packages are nothing more than
a bag of symbols, some public, some private and there are objects
assigned to symbols. So we are working on the same package abstraction
that common lisp is already based on. Backed by a DB instead of
in-memory in the Lisp listener. We don&#x27;t even lose performance since
Common Lisp exposes the &lt;code&gt;compile&lt;&#x2F;code&gt; function to compile lambda forms.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;collaborative-explorative-programming&quot;&gt;Collaborative Explorative Programming&lt;&#x2F;h3&gt;
&lt;p&gt;Expanding this idea a bit more, and to tackle point #5 we could
replace the SQLite with a shared database. Instead of having one set
of mappings you could have one per user while having a shared history.&lt;&#x2F;p&gt;
&lt;p&gt;In order to do this having ways to delete, merge and search the
history database would become needed since the amount of code could
get unwieldy pretty fast. One interesting thing we could do to search
for valid history entries is to be able to create tests for a symbol,
locally but shareable and to be able to run those tests on all&#x2F;some
history entries. You could then see which ones match your
specification or for which tests it fails. It could help narrow down
what parts of the tree were valid and which not. With this you could
even dynamically query the history tree by creating ad-hoc predicates
over inputs and outputs of the functions.&lt;&#x2F;p&gt;
&lt;p&gt;Other interesting ways of developing in groups withh this could be to
allow you to live-track the dev env of another user. Following the
same set of symbol mappings, you could even limit it to certain
functions or function trees (if we kept track of which functions
depend on which functions). That way your friend could be working on
function A while your work on function B and you both have constantly
updated versions of each others functions while you work on yours.&lt;&#x2F;p&gt;
&lt;p&gt;This is not implemented for now, but it would be a natural
extension to the system.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;live-deploy&quot;&gt;Live deploy&lt;&#x2F;h3&gt;
&lt;p&gt;Another interesting thing that we could develop is the ability to
deploy code on a live instance in a way that automatically rolls back
if too many errors happen.&lt;&#x2F;p&gt;
&lt;p&gt;This maybe is too crazy, since there is a reason why we&#x27;ve converged
into deploying dumb stateless services in docker images. We don&#x27;t wanna
deal with a changing environment. But, is it really that different?&lt;&#x2F;p&gt;
&lt;p&gt;Imagine a service that never stops, you diff the existing functions
with the new functions, only updating what needs to be updated. If
there is a change in the rate of errors then you automatically
rollback the deployed functions.  A smarter system could even track
which functions changed their error rate and only rollback any
function that is related in that execution tree that changed in the
last deploy.&lt;&#x2F;p&gt;
&lt;p&gt;It gets harder to track, but maybe it&#x27;s possible.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;concerns-and-worries&quot;&gt;Concerns and worries&lt;&#x2F;h2&gt;
&lt;p&gt;I have two main worries and areas of the system that I&#x27;m unsure how I&#x27;ll tackle:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;How to interact&#x2F;merge this methodology in existing systems that are
file based in a way that doesn&#x27;t add a lot of friction back.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;At the top-level of any common lisp program there may be
expressions not associated with a symbol. I&#x27;m very unsure how to
tackle that if at all. I tend to always wrap everything in
functions anyway, but I don&#x27;t want to impose a particular way of
programming if you wanna use the tool. I need to give this more thought.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;And the final worry, which I think a lot of us have when tackling a
new design space:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Why hasn&#x27;t been done yet before? Is it a bad idea? Does it have
hidden complexities that make it impractical? Do people not develop
like this? Will the idea not be as useful as I expect?&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I guess there is only one way to know :)&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;This is a topic very dear to my heart, it has taken me many years to
come to understand how I best develop software. I&#x27;m not a very
introspective person in general and it has been a long journey.&lt;&#x2F;p&gt;
&lt;p&gt;Hopefuly some of it was interesting and I look forward to learn more
about if these ideas resonate with you and what the problems may be.&lt;&#x2F;p&gt;
&lt;p&gt;I will write another post at some point to show how all this works
from within. It is actually surprisingly small because of the amount
of tools that CL gives the user, but there are some interesting
challenges nontheless.&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;CLOS evolves the instances of any class you define as you evolve the class definition&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;I guess you could have two people remotely controlling the same
repl through swank, but that would get unwieldy quickly&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Small VMs &amp; Coroutines</title>
        <published>2023-01-17T00:00:00+00:00</published>
        <updated>2023-01-17T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.dziban.net/posts/small-vms-and-coroutines/"/>
        <id>https://blog.dziban.net/posts/small-vms-and-coroutines/</id>
        
        <content type="html" xml:base="https://blog.dziban.net/posts/small-vms-and-coroutines/">&lt;h1 id=&quot;tl-mdwr&quot;&gt;TL;MDWR&lt;&#x2F;h1&gt;
&lt;p&gt;In this post I&#x27;ll talk about the implementation of the coroutine system in x64 asm for a game I&#x27;m writing.&lt;&#x2F;p&gt;
&lt;p&gt;(Disclaimer: I&#x27;m very new at x64 assembly programming, so I may be doing some very stupid things)&lt;&#x2F;p&gt;
&lt;h1 id=&quot;background&quot;&gt;Background&lt;&#x2F;h1&gt;
&lt;p&gt;I&#x27;ve had this idea for a while of a programmable game. I&#x27;m not gonna go into details for now but the main idea
is a Real-time strategy game (RTS) where you can program every unit. The code of the units runs in a very simple 
fantasy stack virtual machine, and every tick each unit gets to execute a certain amount of instructions&lt;br &#x2F;&gt;
based on their virtual CPU speed.&lt;&#x2F;p&gt;
&lt;p&gt;As this is an RTS, lots of units are running at the same time and so we need a way to efficiently run all of these
units at a speed reasonable for an interactive videogame (60fps). Some years ago I did some tests around this idea and the VMs 
I came up with were underperforming messes of either rust or C. There was no way I could deliver the performance I 
had in mind with that.&lt;&#x2F;p&gt;
&lt;p&gt;Recently while reading the first volume of &lt;a href=&quot;https:&#x2F;&#x2F;www-cs-faculty.stanford.edu&#x2F;~knuth&#x2F;taocp.html&quot;&gt;The Art of Computer Programming&lt;&#x2F;a&gt; 
I came across a section when Knuth implements coroutines in his MIX machine. And, while I had heard and used 
coroutines informaly all the time in my career I had never seen it like this. For those who don&#x27;t know, a coroutine
is a kind of subroutine that can be suspended and resumed, they are like concurrent-less threads. Each coroutine
has it&#x27;s own stack and instruction pointer. You may have encountered asymmetrical coroutines in the form of python 
generators for example. If you need more context please check the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Coroutine&quot;&gt;coroutine page at wikipedia&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;So I had two ideas at about the same time, convert the code of the Fantasy VM to x64 asm code and run to the code for the
unit VMs as tiny individual coroutines. This both avoids expensive thread context switches, and completely removes the need for
coordinating. I still have to run some benchmarks but I believe splitting the VMs by power (lots of small units in a thread,
some powerful units in another) may bring the best performance results. I may create a separate blogpost once I benchmark this
properly.&lt;&#x2F;p&gt;
&lt;p&gt;So let&#x27;s get started!&lt;&#x2F;p&gt;
&lt;h1 id=&quot;fantasy-asm-to-x64-asm&quot;&gt;Fantasy ASM to x64 ASM&lt;&#x2F;h1&gt;
&lt;p&gt;The first one seems very obvious in hindsight, why spend time implementing the VM when the CPU it is running on already
implements most of the things I want? With some simple macros I can even mostly feed the Fantasy ISA program into an assembler and it
will come out as expected.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s work with a very reduced version of the VM instruction set, just three simple instructions:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Instr&lt;&#x2F;th&gt;&lt;th&gt;Description&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;PUSH&lt;&#x2F;td&gt;&lt;td&gt;Push immediate to stack&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;ADD&lt;&#x2F;td&gt;&lt;td&gt;Add the top two items of the stack. Place result on stack&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;JMP&lt;&#x2F;td&gt;&lt;td&gt;Jump to label&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Let&#x27;s create a very dumb program with this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ASM&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-ASM &quot;&gt;&lt;code class=&quot;language-ASM&quot; data-lang=&quot;ASM&quot;&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;_co_start:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;PUSH &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;0x01
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;loop&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;PUSH &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;0x01
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;ADD
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;JMP loop
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It basically adds &lt;code&gt;0x01&lt;&#x2F;code&gt; constantly to a value on the stack, forever. It&#x27;s an infinite loop.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can use an assembler with macro support to implement these operations in x64. I&#x27;ll be using &lt;a href=&quot;https:&#x2F;&#x2F;flatassembler.net&#x2F;&quot;&gt;fasm&lt;&#x2F;a&gt; for this.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;macro &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;JMP &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;target {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;inc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;jmp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;target
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;macro &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;ADD &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;inc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;pop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;WORD &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;bx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;WORD &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rsp&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;bx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;macro &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;PUSH &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;number {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;inc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;push &lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;WORD &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;number
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Several things to note, I&#x27;m using &lt;code&gt;inc rax&lt;&#x2F;code&gt; in every instruction because I want a way to know how many virtual instructions have executed in order
to impose limits on number of instructions per tick. &lt;code&gt;rax&lt;&#x2F;code&gt; holds this counter. &lt;code&gt;JMP&lt;&#x2F;code&gt; and &lt;code&gt;PUSH&lt;&#x2F;code&gt; are exactly the same instruction as the x64 counterpart, they map 1 to 1. 
&lt;code&gt;ADD&lt;&#x2F;code&gt; is very simple as well: use &lt;code&gt;bx&lt;&#x2F;code&gt; as a temporary storage for the top value of the stack, add the top value of the stack with &lt;code&gt;bx&lt;&#x2F;code&gt; and store in 
back to the top of the stack.&lt;&#x2F;p&gt;
&lt;p&gt;With these macros in place, passing the Fantasy ISA input to fasm already gives us a valid x64 program. The result of the macro expansion would look
like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;_co_start:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;inc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;push &lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;WORD &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;0x01
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;loop&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;inc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;push &lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;WORD &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;0x01
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;inc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;pop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;WORD &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;bx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;WORD &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rsp&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;bx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;inc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;jmp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;target
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In very few lines we have an assembler for our fantasy VM to native x64 code! Now, currently this will loop forever and we don&#x27;t want that, this is where
coroutines come and save the day.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;coroutines&quot;&gt;Coroutines&lt;&#x2F;h1&gt;
&lt;p&gt;How do we make sure that the unit vm only executes N instructions before it suspends itself? A pretty lightweight solution that requires very little setup
is to insert a check that we haven&#x27;t exceeded the number of operations every &lt;code&gt;K&lt;&#x2F;code&gt; ops and after every label (in the unit VM you can only jump to labels, 
so we catch all loops, branches and sketchy stuff with this).&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;I know that this doesn&#x27;t ensure that the VMs execute exactly N operations, but I think it is a pretty good tradeoff between code size, execution
overhead and constraining the number of ops. I&#x27;ll show one possible mitigation further down.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;So how do we implement these lightweight unit coroutines?&lt;&#x2F;p&gt;
&lt;p&gt;First we need to save several things per coroutine:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;current stack pointer (&lt;code&gt;rsp&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;current instruction pointer (&lt;code&gt;rip&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;current &lt;code&gt;rax&lt;&#x2F;code&gt; where we save the amount of instructions executed&lt;&#x2F;li&gt;
&lt;li&gt;current &lt;code&gt;rbx&lt;&#x2F;code&gt; that is used for some temporal values, this one is not strictly needed and there is a chance I remove it in the future&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Usually these things are saved in the stack with normal coroutines but we don&#x27;t want to taint the stack of the unit vms with unrelated data.
First because that means their stack gets reduced for reasons unrelated to their code, second because they may be able to manipulate the stack
to the point where they override the values, and then all hell breaks loose. &lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s start with a simple example where we have 10 units, so let&#x27;s allocate 40 (4 fields * 10 coroutines) 64-bit values and 800 bytes of 
total stack (80 per coroutine).&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#999580;&quot;&gt;; co-routine data, 40 quad-word sized (8 bytes), zeroed buffer
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;_co_data:	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;dq &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;40 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;dup &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;data_stack:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; Allocate 400 word sized (2 bytes), zeroed buffer
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;dw &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;400 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;dup &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;end_data_stack:
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and initialize the data in them:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;_start:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;         ; Main VM start
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;xor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;                ; Initialize rax to 0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; Set rdx to the end of the stack, we will use this to 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; assign stacks to each coroutine, we start from the end
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rdx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;end_data_stack     
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; rcx will be the moving pointer through the _co_data 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; structure as we save the data
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rcx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;_co_data           
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; Loop over all 10 coroutines to...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;init_co_loop:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; Initialize the rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;QWORD &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rcx&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rdx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; Initialize the rip
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;QWORD &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rcx &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;24&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;_co_start
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; Move to the next structure in _co_data
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rcx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;32
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; Move back to the next coroutine start of the stack
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; Each coroutine in this example gets 80 bytes
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;sub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rdx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;80
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; Loop stuff
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;inc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;cmp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;10
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;jl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;init_co_loop
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now let&#x27;s loop over the coroutines, when we &lt;code&gt;yield&lt;&#x2F;code&gt; to the first one we will wait until it &lt;code&gt;yield&lt;&#x2F;code&gt;s control back to the main loop, then it will
continue on to the second, and so on. While you read the next code fragment, always keep in mind that all across the execution &lt;em&gt;&lt;code&gt;rcx&lt;&#x2F;code&gt; always points to the
currently active coroutine data.&lt;&#x2F;em&gt; &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;co_initialized:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; i = 0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;xor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; we will start with the first co-routine
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;mov &lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;QWORD &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rcx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;_co_data
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;_loop:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; yield to the coroutine
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	YIELD
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; i += 1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;inc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; move onto the next coroutine
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rcx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;32
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; Loop things
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;cmp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;10
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;jl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;_loop
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;jmp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;_exit
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now all the magic seems to happen in this &lt;code&gt;YIELD&lt;&#x2F;code&gt; macro, let&#x27;s take a look:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;macro YIELD reset_rax {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; local turns these labels into local labels, so multiple uses of
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; YIELD don&amp;#39;t create repeated labels.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	local next_inst&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;after_yield
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; swap rsp, by the stored value in rsp (this means we just saved
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; the value of the main program rsp to the co_data structure pointed
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; by rcx)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;xchg &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rsp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;QWORD &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rcx&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; swap rax, same as above
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;xchg &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;QWORD &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rcx &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; swap rbx, same as above
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;xchg &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rbx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;QWORD &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rcx &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; now we push onto the stack the instruction pointer for the coroutine
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; which will be used by the &amp;quot;ret&amp;quot; instruction further down
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;push &lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;QWORD &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rcx &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;24&lt;&#x2F;span&gt;&lt;span&gt;]	
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; we call next_inst to get the instruction pointer of this coroutine.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; We don&amp;#39;t wanna return to the next &amp;quot;pop&amp;quot; so we will need to increment
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; this value so that a yield to this coroutine returns right after the
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; &amp;quot;ret&amp;quot;. The call will put this rip into the stack
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;next_inst
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;next_inst:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; move the just save rip into the rip of the _co_data[coroutine_id]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;pop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;QWORD &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rcx &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;24&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; increment it so a yield from the other coroutine continues from right
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; after the ret
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#1fad83;&quot;&gt;QWORD &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rcx &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;24&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;(after_yield &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;next_inst)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; jump, using the value pushed 4 instructions above, into the coroutine
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;ret
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;after_yield:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There are probably some better ways to implement this, but this is what I came up with. Each call into a coroutine saves the main coroutine state
into the &lt;code&gt;_co_data&lt;&#x2F;code&gt; of the coroutine you &lt;code&gt;YIELD&lt;&#x2F;code&gt; into. Once &lt;code&gt;YIELD&lt;&#x2F;code&gt; is called from the other coroutine the same thing will happen, the values for 
the main one will be restored and the execution will continue right after the &lt;code&gt;ret&lt;&#x2F;code&gt;. This works very well for our case of a main coroutine coordinating
other coroutines.&lt;&#x2F;p&gt;
&lt;p&gt;There is one last piece left, injecting some instructions to check if we&#x27;ve exhausted our instruction limit this tick. To do so I created this macro:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;macro CHECK_LIMITS {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	local no_yield
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; in this case the 15k instruction limit is hardcoded, it could
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; be passed as an argument to the macro as when you generate the
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; code, you can set a limit per unit depending on their virtual cpu
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;cmp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;15000		
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;jl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;no_yield
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; If we are above, YIELD
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	YIELD 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; Initialize rax to 0 to reset the counter, here is where the mitigation
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; that I talked about before could happen, here you could subtract by 15k
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; and you&amp;#39;d compensate going over the instruction limit last iteration
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; by having less instructions this loop. This is still not perfect but I
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; think it&amp;#39;s mostly fine. If people found a way to exploit this, I&amp;#39;d
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; be happy to let them.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;xor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d73737;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;no_yield:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;and we can modify the original program like so:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ASM&quot; style=&quot;background-color:#fefbec;color:#6e6b5e;&quot; class=&quot;language-ASM &quot;&gt;&lt;code class=&quot;language-ASM&quot; data-lang=&quot;ASM&quot;&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;_co_start:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;PUSH &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;0x01
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;loop&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#999580;&quot;&gt;	; On every loop start, check if we&amp;#39;ve exceeded the max
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	CHECK_LIMITS
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;PUSH &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b65611;&quot;&gt;0x01
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;ADD
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#6684e1;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b854d4;&quot;&gt;JMP loop
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;some-small-notes&quot;&gt;Some small notes&lt;&#x2F;h1&gt;
&lt;p&gt;This coroutine implementation is very specific. For general purpose coroutines you&#x27;d have to save some more registers than &lt;code&gt;rip&lt;&#x2F;code&gt;, &lt;code&gt;rsp&lt;&#x2F;code&gt;, &lt;code&gt;rax&lt;&#x2F;code&gt; and &lt;code&gt;rbx&lt;&#x2F;code&gt;.
This works in this case because I&#x27;ve assigned a very specific meaning to each register that works all across the implementation, this allows for a smaller
and faster switching between coroutines than a general version.&lt;&#x2F;p&gt;
&lt;p&gt;Another thing is that right now this is very static, but I think it&#x27;s fairly simple to see how to make it dynamic on the number of coroutines and having
different starting labels for each coroutine.&lt;&#x2F;p&gt;
&lt;p&gt;Right now with the implementation I&#x27;ve shown there is no stack security to simplify the idea, but of course the &lt;code&gt;PUSH&lt;&#x2F;code&gt; and &lt;code&gt;POP&lt;&#x2F;code&gt; instructions should have
boundary checks.&lt;&#x2F;p&gt;
&lt;p&gt;Another point is that the &lt;code&gt;inc rax&lt;&#x2F;code&gt; for every operation may add too much overhead, another option that I need to explore is adding an &lt;code&gt;add rax, &amp;lt;immediate&amp;gt;&lt;&#x2F;code&gt;
right before any jump operation. I believe this should be enough to reduce the overhead and it should cover all cases but I need to investigate further.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;the-end&quot;&gt;The End&lt;&#x2F;h1&gt;
&lt;p&gt;Hope this was informative and clear, if you have any question or you wanna talk, please let me know at &lt;code&gt;marce [at] dziban.net&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>An experimental Development Environment</title>
        <published>2019-11-27T00:00:00+00:00</published>
        <updated>2019-11-27T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://blog.dziban.net/blog/first/"/>
        <id>https://blog.dziban.net/blog/first/</id>
        
        <content type="html" xml:base="https://blog.dziban.net/blog/first/">&lt;p&gt;Development environments of today look not that different from the ones from 10 or 20 years ago.
Sure, we have different tooling, different languages, we use a lot more tooling but the core remains
mostly the same. Organizing code in text files, edit those files using a text editor, using those text 
files as input for an interpreter or compiler, check the files into a source control system. Once you have
something you like you commit it, and at some point generate a build and deploy it.&lt;&#x2F;p&gt;
&lt;p&gt;There are of course differences between environments and what you can do in them, but these are mostly the
same.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;a-survey-of-interactive-development&quot;&gt;A Survey of Interactive Development&lt;&#x2F;h2&gt;
&lt;p&gt;At this point, for me there is no better development system than interactive programmming, perfectly exemplified
by one of the Lisps, my lisp of choice is Common Lisp and everytime I refer to Lisp in this essay I&#x27;m refering to it
but probably a lot of this applies to any other Lisp.&lt;&#x2F;p&gt;
&lt;p&gt;The ability to continuously evolve the state and the code of the program while doing exploratory programming is
THE superpower of Lisp in my opinion. I don&#x27;t know about you, but I cannot really plan very well in advance and I need to explore
the problem space interactively to get a good hang on what the problem and the program is about.&lt;&#x2F;p&gt;
&lt;p&gt;A lot of design of Common Lisp goes towards enabling this interactivity, CLOS the OOP library of Common Lisp allows you to redefine
classes at runtime and it will update existing instances with the new slots (properties). You can add and remove methods at runtime.
You can also code what updating the instances means if you want something more custom than what is the edefault.&lt;&#x2F;p&gt;
&lt;p&gt;You can redefine functions at runtime, the condition system allows interactivity when dealing with errors. When something happens you
can continue right where you left off.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;an-idea-for-an-alternative&quot;&gt;An idea for an alternative&lt;&#x2F;h2&gt;
&lt;p&gt;Recently I was thinkin&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>

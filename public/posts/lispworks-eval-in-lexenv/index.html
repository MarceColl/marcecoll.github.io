<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
        <meta content="text/html; charset=UTF-8" http-equiv="content-type"/>
        <meta content="width=device-width, initial-scale=1" name="viewport"/>

	<script defer src="https://analytics.eu.umami.is/script.js" data-website-id="d30d7ef2-3933-45d0-a5e0-bf0b464c89f1"></script>

        
        
        

        
        
        

        

        
        
        

        
        
        

        <title>Eval using the lexical environment in LispWorks</title>
        
        <meta name="title" content="Eval using the lexical environment in LispWorks">
        <meta name="author" content="Marce Coll">
        
        <meta name="generator" content="Zola v0.16.1">

        <meta property="og:type" content="website">
        <meta property="og:url" content="https://blog.dziban.net/posts/lispworks-eval-in-lexenv/">
        <meta property="og:site_name" content="">
        <meta property="og:title" content="Eval using the lexical environment in LispWorks">
        
        <meta property="og:image" content="https:&#x2F;&#x2F;blog.dziban.net&#x2F;images&#x2F;logo.png">

        
        
        <meta property="twitter:card" content="summary_large_image">
        <meta property="twitter:url" content="https://blog.dziban.net/posts/lispworks-eval-in-lexenv/">
        <meta property="twitter:title" content="Eval using the lexical environment in LispWorks">
        
        <meta property="twitter:image" content="https:&#x2F;&#x2F;blog.dziban.net&#x2F;images&#x2F;logo.png">
        
        
        <link rel="canonical" href="https://blog.dziban.net/posts/lispworks-eval-in-lexenv/">
        <link rel="shortcut icon" type="image/x-icon" href="https://blog.dziban.net/images/logo.png">
        <script type="application/ld+json">
            {
                
                "url":"https://blog.dziban.net/posts/lispworks-eval-in-lexenv/",
                "@type":"WebSite",
                "headline":"Eval using the lexical environment in LispWorks",
                "name":"Eval using the lexical environment in LispWorks",
                "author":{
                    "@type":"Person",
                    "name":"Marce Coll"
                },
                "@context":"https://schema.org"
            }
        </script>
        
        
        
        <link rel="alternate" type="application/atom+xml" title="RSS" href="https://blog.dziban.net/atom.xml">
        
        
        
        <link rel="stylesheet" href="https://blog.dziban.net/style.css"/>
        
    </head>
    <body theme="auto">
        <div class="w">
            <header>
                
                <nav>
                    
                    <a href="/" >~home</a>
                    
                    <a href="/exploratory-programming" >(exp prog)</a>
                    
                    <a href="/essays/" >*essays</a>
                    
                    <a href="/posts/" >@posts</a>
                    
                </nav>
                
                
<p><a href="..">..</a>/lispworks-eval-in-lexenv</p>
<p class="post-meta"><time datetime="2024-04-03">2024-04-03</time></p>
<h1>Eval using the lexical environment in LispWorks</h1>

            </header>
            <main class="page-content" aria-label="Content">
                



<p>One of the things that surprised me when I learned Common Lisp was
that <code>eval</code> happens in the <code>nil</code> lexical environment<sup class="footnote-reference"><a href="#1">1</a></sup>. This means
that none of the lexical variables, functions or macros surrouding the
eval are available to use in the evaled form.</p>
<p>For example</p>
<pre data-lang="lisp" style="background-color:#fefbec;color:#6e6b5e;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#b854d4;">let </span><span>((x </span><span style="color:#b65611;">4</span><span>))
</span><span>  (</span><span style="color:#1fad83;">eval</span><span> &#39;(+ x </span><span style="color:#b65611;">2</span><span>)))
</span><span>  
</span><span>Error: The variable X is unbound.
</span></code></pre>
<p>The reason why that surprised me is that one of the first things that
I tried when I learned about lisp symbolic capabilities was to build a
symbolic
<a href="https://en.wikipedia.org/wiki/Derivative">differentiator</a>. You'd give
it a function, it would symbolically compute the derivative using
the chain rule and then evaluate it. I built a very basic one with
only a couple of rules to test the idea and it seemed to work, the
problem was when I wanted to evaluate the resulting form.</p>
<p>What I attempted was something like this:</p>
<pre data-lang="lisp" style="background-color:#fefbec;color:#6e6b5e;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#b854d4;">defun </span><span style="color:#6684e1;">dx </span><span>(func x)
</span><span>  (</span><span style="color:#b854d4;">let </span><span>((derivative (differentiate func :over &#39;x)))
</span><span>    (</span><span style="color:#1fad83;">eval</span><span> derivative)))
</span></code></pre>
<p>If you try this of course you'll face the same issue we found above.
<code>Error: The variable X is unbound</code>. I was confused, I thought symbolic
computation WAS the point of Lisp. At that point I learned about the
dynamic vs lexical environment and I started making sense of what I
was seeing, but I was frustrated and it seemed that what I wanted to
do was impossible.</p>
<p>Now of course you could do it with a macro, but then you cannot pass
it arbitrary functions at runtime, everything has to be predefined. </p>
<p>Another option was available which was to declare x as special<sup class="footnote-reference"><a href="#2">2</a></sup>,
but then you needed to keep some special variables around, and the
expressions could only use those. It would work but it was not ideal.</p>
<p>At that point I stopped, frustrated, and learned other parts of the
language. Recently I had a need for something similar again and so I
set to find a solution now that I had some more Common Lisp experience
under my belt.</p>
<h2 id="progv"><code>PROGV</code></h2>
<p><a href="http://clhs.lisp.se/Body/s_progv.htm"><code>PROGV</code></a> is a Common Lisp
special form that takes three or more arguments, a list of dynamic
bindings to create, a list of values to set the bindings to and any
number of forms. The forms are evaluated in order with the given 
dynamic bindings set.</p>
<pre data-lang="lisp" style="background-color:#fefbec;color:#6e6b5e;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#b854d4;">defun </span><span style="color:#6684e1;">test-fun </span><span>()
</span><span>  (+ *</span><span style="color:#d73737;">x</span><span>* </span><span style="color:#b65611;">3</span><span>))
</span><span>
</span><span>(progv &#39;(*</span><span style="color:#d73737;">x</span><span>*) &#39;(</span><span style="color:#b65611;">2</span><span>)
</span><span>  (test-fun))
</span><span>  
</span><span>=&gt; 5
</span></code></pre>
<p>With this we can emulate a en eval in a lexical env by setting
everything we have in the lexical environment as a dynamic variable
inside a <code>PROGV</code> and then executing the eval. It will behave as if
it was running on the lexenv.</p>
<p>This would be a good moment to see where we are going:</p>
<pre data-lang="lisp" style="background-color:#fefbec;color:#6e6b5e;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#b854d4;">let </span><span>((x </span><span style="color:#b65611;">4</span><span>))
</span><span>  (</span><span style="color:#1fad83;">eval</span><span>-in-lexenv (+ x </span><span style="color:#b65611;">2</span><span>)))
</span><span>  
</span><span>=&gt; 6
</span></code></pre>
<p>Which behind the scenes would be transformed into a <code>PROGV</code> form:</p>
<pre data-lang="lisp" style="background-color:#fefbec;color:#6e6b5e;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(progv &#39;(x) &#39;(</span><span style="color:#b65611;">4</span><span>)
</span><span>  (</span><span style="color:#1fad83;">eval</span><span> &#39;(+ x </span><span style="color:#b65611;">2</span><span>)))
</span></code></pre>
<p>Now the problem is, <code>eval-in-lexenv</code> cannot modify its surroundings,
macros are powerful but not <em>THAT</em> powerful<sup class="footnote-reference"><a href="#3">3</a></sup>. We could ask the
users to do something like this:</p>
<pre data-lang="lisp" style="background-color:#fefbec;color:#6e6b5e;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#1fad83;">eval</span><span>-</span><span style="color:#b854d4;">with</span><span>-</span><span style="color:#b854d4;">let </span><span>(</span><span style="color:#b854d4;">let </span><span>((x </span><span style="color:#b65611;">4</span><span>)) (</span><span style="color:#1fad83;">eval</span><span> &#39;(+ x </span><span style="color:#b65611;">2</span><span>))))
</span></code></pre>
<p>And then build a code walker, check bindings inside, capture some
bindings from outside, etc. But that is very complicated and there are
probably plenty of edge cases and problems, it's far too complicated
and too alien for the user to be worth it in this case.</p>
<h2 id="introspecting-the-lexical-environment">Introspecting the lexical environment</h2>
<p><code>DEFMACRO</code>'s arglist has a hidden gem that I overlooked the first time
I checked the documentation. With <code>&amp;environment</code> we can ask the lisp
compiler to give us the lexical environment<sup class="footnote-reference"><a href="#4">4</a></sup> at the macro call site.</p>
<p>For example</p>
<pre data-lang="lisp" style="background-color:#fefbec;color:#6e6b5e;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#b854d4;">defmacro </span><span style="color:#6684e1;">capture-env </span><span>(&amp;environment env)
</span><span>  env)
</span><span>  
</span><span>(flet ((plus (a b) (+ a b)))
</span><span>  (</span><span style="color:#b854d4;">let </span><span>((x </span><span style="color:#b65611;">4</span><span>))
</span><span>    (capture-env)))
</span><span>
</span><span>=&gt; #&lt;Environment 
</span><span>       venv (</span><span style="color:#b65611;">#&lt;Venv 275146972128</span><span>  X&gt;)  
</span><span>	   fenv ((PLUS . </span><span style="color:#b65611;">#&lt;COMPILER::FLET-INFO #&lt;interpreted</span><span> function (SUBFUNCTION (FLET PLUS) :UNKNOWN) 40200038FC&gt;&gt;)) 
</span><span>	   benv NIL 
</span><span>	   tenv NIL&gt;
</span></code></pre>
<p>It contains variables, functions, blocks and tags in the lexical
environment. But, I'm pretty sure this struct is internal and the
intrface may not be stable. Re-reading the LispWorks documentation
today I found this function:
<a href="https://www.lispworks.com/documentation/lw80/lw/lw-sys-93.htm"><code>SYSTEM:MAP-ENVIRONMENT</code></a>.
With this function you can introspect everything in the lexical
environment you pass as an argument. Let's write a function to get all
variable names in the lexical environment for example.</p>
<pre data-lang="lisp" style="background-color:#fefbec;color:#6e6b5e;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#b854d4;">defun </span><span style="color:#6684e1;">lexical-vars </span><span>(env)
</span><span>  &quot;</span><span style="color:#60ac39;">Given an environment object, return all lexical vars</span><span>&quot;
</span><span>  (</span><span style="color:#b854d4;">let </span><span>((vars </span><span style="color:#b65611;">nil</span><span>))
</span><span>    (system:</span><span style="color:#1fad83;">map</span><span>-environment env
</span><span>     :variable
</span><span>     (</span><span style="color:#1fad83;">lambda </span><span>(name kind info)
</span><span>       (declare (ignore info))
</span><span>       (</span><span style="color:#b854d4;">when </span><span>(eq kind :lexical)
</span><span>         (</span><span style="color:#1fad83;">pushnew</span><span> name vars))))
</span><span>    vars))
</span></code></pre>
<p>Pretty self-explanatory, ask lispworks to map over all the variables,
and then we push them into a list. We filter them by <code>:LEXICAL</code> type
because we are also given dynamic variables that have been overwritten
in the current lexical scope, but we don't need to use those since
they are already in the dynamic scope.</p>
<p>Now let's create the <em>pièce de résistance</em>, the <code>eval-in-lexenv</code>
macro:</p>
<pre data-lang="lisp" style="background-color:#fefbec;color:#6e6b5e;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#b854d4;">defmacro </span><span style="color:#6684e1;">eval-in-lexenv </span><span>(&amp;body body &amp;environment env)
</span><span>  (</span><span style="color:#b854d4;">let </span><span>((lenv-vars (lexical-vars env)))
</span><span>     `(progv &#39;,lenv-vars (</span><span style="color:#1fad83;">list</span><span> ,@lenv-vars)
</span><span>	    (</span><span style="color:#1fad83;">eval</span><span> ,(</span><span style="color:#1fad83;">car</span><span> body)))))
</span><span>		
</span><span>(</span><span style="color:#b854d4;">let </span><span>((x </span><span style="color:#b65611;">2</span><span>))
</span><span>  (</span><span style="color:#1fad83;">eval</span><span>-in-lexenv (+ x </span><span style="color:#b65611;">2</span><span>)))
</span><span>  
</span><span>=&gt; 4
</span></code></pre>
<p>Short and sweet, we get all the lexical variables, then we pass them
both as names and values to <code>PROGV</code>. As names we pass them quoted, so
we get bind the same symbols we have of lexical vars as dynamic
variables, for values we pass them unquoted inside of a <code>(LIST ...)</code>
so they get evaluated and capture the values from the surrounding
lexical env, thus setting the dynamic variables to the same values.</p>
<p>There you go, a way to eval in the lexical environment in about 14
lines of easy to understand common lisp code. This code is LispWorks
exclusive tho, but I'm sure there are ways to do it in SBCL, since
<code>&amp;environment</code> works there as well. I may add it in the future if
someone sends me a solution that works in SBCL.</p>
<h2 id="limitations">Limitations</h2>
<p>This implementation doesn't allow using functions and macros from the
lexical env (as defined by <code>MACROLET</code> or <code>FLET</code>) although there are
ways around it, like binding the function to a variable and using
<code>FUNCALL</code> or <code>APPLY</code> inside the eval.</p>
<pre data-lang="lisp" style="background-color:#fefbec;color:#6e6b5e;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#b854d4;">let </span><span>((fn (</span><span style="color:#1fad83;">lambda </span><span>(a b) (+ a b))))
</span><span>   (</span><span style="color:#1fad83;">eval</span><span>-in-lexenv (</span><span style="color:#1fad83;">funcall</span><span> fn </span><span style="color:#b65611;">3 4</span><span>)))
</span><span>   
</span><span style="color:#999580;">; =&gt; 7
</span></code></pre>
<p>Another thing is that this macro depends on being called at the
lexical environment you want to evaluate it.</p>
<p>If you try to call this macro from within the body of a macro function
you'll be capturing the call environment inside the macro. Of course
if you use it as part of the unevaluated returned form of the macro
everything will work as expected, since that will be evaluated in the
correct lexical environment.</p>
<h2 id="setf-shenanigans"><code>SETF</code> shenanigans</h2>
<p>There is a question I have for readers, because there is a bit of a
puzzling behaviour I've seen with this implementation in LispWorks.</p>
<p>When using <code>eval-in-lexenv</code>, if inside the evaled expression you
<code>setf</code> one of the lexical environment variables, that setf escapes to
the actual lexical environment instead of being contained to the
<code>PROGV</code>. Does anyone know why that is the case? Can someone try it in
another implementation?</p>
<p>Example:</p>
<pre data-lang="lisp" style="background-color:#fefbec;color:#6e6b5e;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#b854d4;">let </span><span>((x </span><span style="color:#b65611;">2</span><span>))
</span><span>  (</span><span style="color:#1fad83;">eval</span><span>-in-lexenv (</span><span style="color:#1fad83;">setf</span><span> x </span><span style="color:#b65611;">8</span><span>))
</span><span>  (+ x </span><span style="color:#b65611;">2</span><span>))
</span><span>  
</span><span style="color:#999580;">; =&gt; 10
</span></code></pre>
<p>This is very confusing to me, because it's something that I wanted and
I was checking how to implement it, but it seems at least in LispWorks
it works by default but I'm not sure why it works, since in there you
should be setting the dynamic variable inside the <code>PROGV</code> and not the
lexical variable (since you don't even have access to the lexical one
anyway).</p>
<p><em>The End</em></p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The nil lexical environment, as the name says has no bindings at all</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Special and dynamic variables are the same thing, special variables are variables bound in the dynamic environment</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Recently I learned about a <a href="https://github.com/abuseofnotation/termlisp">term rewriting lisp</a>, which could actually do things like this potentially. I think that particular version is not quite powerful enough for this, but there is no reason it couldn't I think.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>I think it's not only the lexical environment, but the general environment that overlays the dynamic environment, it also contains special variables overriden in the current lexical environment for example.</p>
</div>


            </main>
            <footer>
		    <p style="font-size: 9px">This blog has analytics provided by umami. In the interest of transparency 
		    here is the <a href="https://eu.umami.is/share/bzORj5l3c2coxORD/blog.dziban.net">dashboard</a></p>
                
<p class="taxonomies">

</p>

                
            </footer>
        </div>
    </body>
</html>
        
